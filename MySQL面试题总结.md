# MySQL面试题总结

## 数据库语言

- DQL

  select * from table_name [条件]

- DML

  insert into table_name(字段) values( );

  update table_name set 字段="" where 

  delete * from table_name

- DDL

  create table table_name ()

- DCL

  grant all on table_name to user@localhost

  rollback 

  commit 

## MySQL 备份的方式以及优缺点

- 物理备份：xtrabackup

  完全备份、增量备份、差异备份，备份的是数据文件

- 逻辑备份：mysqldump

  备份的是sql语句，在恢复的时候执行备份的sql语句来实现数据数据的重现

  优缺点：

  ​			物理备份恢复速度比较快，占用空间比较大

  ​			逻辑备份速度比较快，占用空间比较小。逻辑备份的恢复成本高

- 常见的备份方式：

  - 使用xtrabackup 

    xtrabackup是一个用来备份 MySQL数据库的开源工具

    在线支持热备、支持流备份、支持增量备份支持记录slave上的master log 和 master postion信息、支持多个进程同时热备份

  - LVM 

    热备、支持所有基于本地磁盘的存储引擎、快速备份、低开销、容易保持完整性、快速恢复等

  - 使用mysql主从复制

    mysql的复制是指将主数据库的DDL和DML操作通过二进制文件(bin-log)传送到从服务器上，然后在从服务器上对这些日志做重新执行的操作，从而使得从服务器和主服务器保持数据的同步

​			

## 为什么要做mysql主从复制

1. 在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。
2. 做数据的热备，主库宕机后能够及时替换主库，保证业务可用性。
3. 架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。
4. 对于更新不频繁和实时性要求不高的数据在从库进行读操作，可以降低主库的访问压力
5. 可以在从库进行备份，以避免备份期间影响主库的服务

## 主从复制原理

1. 在从节点上执行sart slave命令开启主从复制开关，开始进行主从复制。从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；
2. 主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程（log dump 线程）根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position（bin-log中的下一个指定更新位置）；
3. 从节点的I/O进程接收到主节点发送过来的日志内容、日志文件及位置点后，将接收到的日志内容更新到本机的relay-log（中继日志）的文件（Mysql-relay-bin.xxx）的最末端，并将读取到的binary log（bin-log）文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；
4. Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在主节点上实际执行过SQL语句，然后在本数据库中按照解析出来的顺序执行，并在**relay-log.info**中记录当前应用中继日志的文件名和位置点。

## **MySQL** 主从复制的模式

​	MySQL 主从复制默认是异步的模式。MySQL增删改操作会全部记录在bin-log（binary log）中，当slave节点连接master时，会主动从master处获取最新的bin-log文件。并把bin-log存储到本地的relay-log中，然后去执行relay-log的更新内容

- 异步模式（mysql async-mode）

  异步模式如下图所示，这种模式下，主节点不会主动推送bin-log到从节点，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主节点如果崩溃掉了，此时主节点上已经提交的事务可能并没有传到从节点上，如果此时，强行将从提升为主，可能导致新主节点上的数据不完整。

  ![img](https://img-blog.csdnimg.cn/20200225232927385.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N5OTczMDcxMjYz,size_16,color_FFFFFF,t_70)

- 半同步模式(mysql semi-sync)

     介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay-log中才返回成功信息给客户端（只能保证主库的bin-log至少传输到了一个从节点上，但并不能保证从节点将此事务执行更新到db中），否则需要等待直到超时时间然后切换成异步模式再提交。相对于异步复制，半同步复制提高了数据的安全性，一定程度的保证了数据能成功备份到从库，同时它也造成了一定程度的延迟，但是比全同步模式延迟要低，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。如下图所示：

  ![img](https://img-blog.csdnimg.cn/20200225232927393.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N5OTczMDcxMjYz,size_16,color_FFFFFF,t_70)

  半同步模式不是mysql内置的，从mysql 5.5开始集成，需要master 和slave 安装插件开启半同步模式

- **全同步模式**

  ​    指当主库执行完一个事务，然后所有的从库都复制了该事务并成功执行完才返回成功信息给客户端。因为需要等待所有从库执行完该事务才能返回成功信息，所以全同步复制的性能必然会收到严重的影响

## MySQL主从复制的方式

**MySQL 主从复制有三种方式：基于SQL语句的复制（statement-based replication，SBR），基于行的复制（row-based replication，RBR)，混合模式复制（mixed-based replication,MBR)。对应的bin-log文件的格式也有三种：STATEMENT, ROW, MIXED。**

- **Statement-base Replication (SBR)** 

    就是记录[sql语句](https://so.csdn.net/so/search?q=sql语句&spm=1001.2101.3001.7020)在bin-log中，Mysql 5.1.4 及之前的版本都是使用的这种复制格式。优点是只需要记录会修改数据的sql语句到bin-log中，减少了bin-log日质量，节约I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。

- **Row-based Relication(RBR)**

  **mysql master将SQL语句分解为基于Row更改的语句并记录在bin-log中，也就是只记录哪条数据被修改了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增,同时增加bin-log同步时间。也不能通过bin-log解析获取执行过的sql语句，只能看到发生的data变更。**

- **ixed-format Replication(MBR)**

  MySQL NDB cluster 7.3 和7.4 使用的MBR。是以上两种模式的混合，对于一般的复制使用STATEMENT模式保存到bin-log，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式。

## GTID复制模式

在传统的复制里面，当发生故障，需要主从切换，需要找到bin-log和pos点（指从库更新到了主库bin-log的哪个位置，这个位置之前都已经更显完毕，这个位置之后未更新），然后将主节点指向新的主节点，相对来说比较麻烦，也容易出错。在MySQL 5.6里面，不用再找bin-log和pos点，我们只需要知道主节点的ip，端口，以及账号密码就行，因为复制是自动的，MySQL会通过内部机制GTID自动找点同步。
基于GTID的复制是MySQL 5.6后新增的复制方式.

**GTID (global transaction identifier)** 即全局事务ID, 保证了在每个在主库上提交的事务在集群中有一个唯一的ID.

- 原理

  在原来基于日志的复制中, 从库需要告知主库要从哪个偏移量进行增量同步, 如果指定错误会造成数据的遗漏, 从而造成数据的不一致.

  而基于GTID的复制中, 从库会告知主库已经执行的事务的GTID的值, 然后主库会将所有未执行的事务的GTID的列表返回给从库. 并且可以保证同一个事务只在指定的从库执行一次.通过全局的事务ID确定从库要执行的事务的方式代替了以前需要用bin-log和pos点确定从库要执行的事务的方式。GTID是由server_uuid和事物id组成，格式为GTID=server_uuid:transaction_id。server_uuid是在数据库启动过程中自动生成，每台机器的server-uuid不一样。uuid存放在数据目录的auto.conf文件中，而transaction_id就是事务提交时系统顺序分配的一个不会重复的序列号，主节点更新数据时，会在事务前产生GTID，一起记录到bin-log日志中。从节点的I/O线程将变更的bin-log，写入到本地的relay-log中。SQL线程从relay-log中获取GTID，然后对比本地bin-log是否有记录（所以MySQL从节点必须要开启binary-log）。如果有记录，说明该GTID的事务已经执行，从节点会忽略。如果没有记录，从节点就会从relay-log中执行该GTID的事务，并记录到binlog。在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。

- 优点

  GTID使用master_auto_position=1代替了binlog和position号的主从复制搭建方式，相比binlog和position方式更容易搭建主从复制。

  GTID方便实现主从之间的failover（主从切换），不用一步一步的去查找position和binlog文件。   

- 局限

  不能使用create table table_name select * from table_name模式的语句

  在一个事务中既包含事务表的操作又包含非事务表

  不支持CREATE TEMPORARY TABLE or DROP TEMPORARY TABLE语句操作

  使用GTID复制从库跳过错误时，不支持sql_slave_skip_counter参数的语法

## 多线程复制

多线程复制（基于库），在MySQL 5.6以前的版本，slave的复制是单线程的，而master是并发写入的，所以延时是避免不了的。唯一有效的方法是把多个库放在多台slave，这样又有点浪费服务器。在MySQL 5.6里面，我们可以把多个表放在多个库，这样就可以使用多线程复制。

但 5.6 中的每个线程只能处理一个数据库，所以如果只有一个数据库，或者绝大多数写操作都是集中在某一个数据库的，那么这个“多线程复制”就不能充分发挥作用了。

Mysql 5.7 对 “多线程复制” 进行了改善，可以按照逻辑时钟的方式来分配线程，大大提高了复制性能

## Mysql主从同步延迟问题及解决方案

**问题一：**主库的从库太多，导致复制延迟

​      从库数据以3-5个为宜，要复制的从节点数量过多，会导致复制延迟

**问题二**：从库硬件比主库差，导致复制延迟

​      查看Master和Slave的系统配置，可能会因为机器配置不当，包括磁盘I/O、CPU、内存等各方面因素造成复制的延迟。一般发生在高并发大数据量写入场景中

**问题三：**慢SQL语句过多

​      假如一条SQL语句执行时间是20秒，那么从执行完毕到从库上能查到数据至少需要20秒，这样就延迟20秒了。

​     一般要把SQL语句的优化作为常规工作不断地进行监控和优化，如果单个SQL的写入时间长，可以修改后分多次写入。通过查看慢查询日志或show full processlist命令，找出执行时间长的查询语句或大的事务

**问题四：**主从复制的设计问题

​     例如主从复制单线程，如果主库写并发太大，来不及传送到从库，就会导致延迟。更高版本的Mysql可以支持多线程复制，门户网站则会开发自己的多线程同步功能**。**

**问题五：**主从库之间的网络延迟

​     主从库的网卡、网线、交换机等网络设备都可能成为复制的瓶颈，导致复制延迟。另外，跨公网的主从复制很容易导致主从复制延迟

**问题六：**主库读写压力大，导致复制延迟

​      架构的前端要加buffer及缓存层

**解决思路：**

​     如何避免或解决主从延迟？可以用来解决的办法，有如下的:

- **从库优化Mysql参数。**比如增大innodb_buffer_pool_size，让更多操作在Mysql内存中完成，减少磁盘操作。
- **从库使用高性能主机。**包括cpu强悍、内存加大。避免使用虚拟云主机，使用物理主机，这样提升了i/o方面性。
- **从库使用SSD磁盘。**机械硬盘是靠磁头旋转到指定位置来读数据、写数据。转来转去的，我们叫做i/o。磁盘i/o存在速度瓶颈。固态硬盘是一个电子设备，电子设备不需要机械旋转，读写固态硬盘上任意位置的数据，速度都是一样的。
- **业务代码的妥协。**将实时性要求高的某些操作，使用主库做读操作。比如我写了数据到主库了，需要马上展示数据，不要到从库去读数据，因为从库可能还没同步过去呢。直接从主库读数据，保证是最新的数据展示。
- **从库的线程改为多个同步线程同步数据**。mysql-5.6.3为了解决这个问题，从服务器上，每一个库开一个线程来同步。
-  **网络优化。**网络堵塞，也会导致同步延迟。跨机房的数据库同步，会存在同步延迟。保证主从在同一个机房里面去。

**门户网站的解决方案：**

1. **优酷的解决方案**：数据库分片技术，而抛弃了由于数据量的越来越多导致复制延迟的问题。按照user_id进行分片，这样必须有一个全局的表来管理用户与shard的关系,根据user_id可以得到share_id，然后根据share_id去指定的分片查询指定的数据
2. **淘宝的解决方案**：修改源码，对应的机制是Transfer机制，此处通过对Binlog日志重做采用多线程实现，从而提高slave的Q PPS